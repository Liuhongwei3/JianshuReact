{
  "success": true,
  "data": [
    {
      "id": 1,
      "title": "Cookie、Session和Token",
      "content": "<img class='img' alt='' src='https://upload-images.jianshu.io/upload_images/37341-26521b6eb96b6e21.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp'/><h1>前言</h1><p>Web诞生之初，功能比较单一：允许Internet上任意一个用户都可以从许多文档服务计算机的数据库中搜索和获取文档。服务器不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 即请求加响应，服务器不用记住是谁刚刚发了HTTP请求， 每个请求对服务器来说都是全新的。</p><p>随着<strong>交互式Web</strong>应用的兴起，网站有了登录的需求，如在线购物网站，社交网站等等。这就面临一个问题，服务器必须记住哪些人登录了系统，  哪些人往自己的购物车中添加了商品，  也就是说服务器要识别每个用户。</p><p>因为HTTP请求是无状态的，所以想出的办法就是给大家发一个<strong>会话标识(session id)</strong>， 说白了就是一个随机的字串，每个用户收到的都不一样。 当用户向服务器发起HTTP请求的时候，带上这个字符串， 这样服务器就能识别不同的用户了。</p><p>所以就有了Session的引入，即服务端和客户端都保存一段文本，客户端每次发起请求都带着，这样服务器就知道客户端是否发起过请求。</p><p>这样，就导致客户端频繁向服务端发出请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否。而Session的存储是需要空间的，频繁的查询数据库给服务器造成很大的压力。</p><p>随着Web移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。</p><p>基于服务器验证方式暴露的一些问题</p><p>1.Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。</p><p>2.可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。</p><p>3.CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。</p><p>4.CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。</p><p>于是有人就一直在思考， 服务器为什么要保存这些信息呢， 只让每个客户端去保存该多好？</p><p>在这种情况下，Token应用而生。</p><p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。当客户端第一次访问服务端，服务端会根据传过来的唯一标识userId，运用一些算法，并加上密钥，生成一个Token，然后通过BASE64编码一下之后将这个Token返回给客户端，客户端将Token保存起来（可以通过数据库或文件形式保存本地）。下次请求时，客户端只需要带上Token，服务器收到请求后，会用相同的算法和密钥去验证Token。</p>"
    },
    {
      "id": 2,
      "title": "HTTP协议浅谈",
      "content": "<img class='img' alt='' src='https://upload-images.jianshu.io/upload_images/3290028-42599267cfd2f2fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/751/format/webp'/><h2>定义</h2><p>HTTP( HyperText Transfer Protocol )超文本传输协议 ，是一种用于分布式、协作式和超媒体信息系统的<em>应用层</em>协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p><h2>TCP/IP &amp; HTTP</h2><ol><li>HTTP是如何建立连接的<br>首先我们要看下熟知的七层网络模型(计算机网络中的七层模型毕竟是理想中的情况，现实是很少有应用实现了七层模型，一般都是整合其中两个或多个，实现一个四层或者五层的模型)和TCP/IP的四层网络模型（TCP处于传输层，IP属于网络(际)层  ps:关于TCP/IP究竟是几层协议，目前为止没有定论，四层和五层都有，这里不展开讨论 ），如下图</li></ol><p>在这里我们研究的是HTTP，自然要知道它所处在哪个模型中，答案是应用层<br>因为HTTP是基于TCP/IP开发的协议，看过HTTP协议的同学肯定都知道，有句话概述HTTP协议为无差错的协议，按序传输，未分段的数据流，这其实说的就是TCP协议。</p><ol start=\"2\"><li>当你在浏览器输入一个URL的时候，其中发生了什么？<ul><li>获取主机名</li><li>DNS 缓存/ 解析 获取服务器IP + 端口 (浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存)</li><li>连接到服务器 （这里其实是TCP连接）</li><li>通过TCP信道发送一个HTTP请求</li><li>服务器读取一个HTTP请求</li><li>服务器查找所需资源并通过TCP信道返回资源</li><li>关闭TCP连接</li></ul></li></ol><h2>版本变迁</h2><ol><li>HTTP/0.9    已过时,只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头.</li><li>HTTP/1.0    第一个在通讯中指定版本号的HTTP 协议版本。</li><li><em>HTTP/1.1</em>     继承了HTTP1.0简单的特点，持久连接被默认建立，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。</li><li><em>HTTP/2.0</em>    2015年5月作为互联网标准正式发布。</li></ol><h2>HTTP客户端请求和服务端响应（目前主流的HTTP1.1和HTTP2</h2><ul><li>请求组成<ol><li>起始行(start line)<br>请求方法 + 请求URI + 协议版本</li><li>报文首部（Header）</li><li>空行</li><li>报文主体</li></ol></li><li>响应组成<ol><li>起始行(start line)<br>协议版本 + 状态码 + 状态嘛的原因短语</li><li>报文首部（Header）</li><li>空行</li><li>报文主体</li></ol></li><li>请求方法<ul><li>GET    —    获取资源</li><li>HEAD  —    获得报文首部</li><li>POST  --    传输实体文本</li><li>PUT    --    传输文件</li><li>DELETE    —    删除文件</li><li>CONNECT    —    要求用隧道协议连接代理</li><li>OPTIONS    —    询问支持的方法</li><li>TRACE    —    追踪路径</li></ul></li><li>首部文件  <em>这一块图解HTTP的第六章有详细内容</em><ul><li>通用首部<ol><li>信息：Connection/Date/MIME-Version/Trailer/Update/Via</li><li>缓存：Cache-Control/Pragma</li></ol></li><li>请求首部<ol><li>信息：Client-IP/From/Host/Referer/UA-Color/UA-CPU/UA-Disp/UA-OS/UA-Pixels/User-Agent</li><li>Accept：Accept/Accept-Charset/Accept-Encoding/Accept-Language/TE</li><li>条件请求：Expect/If-Match/If-Modified-Since/If-None-Match/If-Range/If-Unmodified-Since/Range</li><li>安全请求：Authorization/Cookie/Cookie2</li><li>代理请求：Max-Forward/Proxy-Authorization/Proxy-Connection</li></ol></li><li>响应首部<ol><li>信息：Age/Public/Retry-After/Server/Title/Warning</li><li>协商：Accept-Ranges/Vary</li><li>安全响应：Proxy-Authorization/Set-Cookie/Set-Cookie2/WWW-Authenticate</li></ol></li><li>实体首部<ol><li>信息：Allow/Location</li><li>内容：Content-Base/Content-Encoding/Content-Language/Content-Length/Content-Location/Content-MD5/Content-Range/Content-Type</li><li>实体缓存：ETag/Expires/Last-Modified</li></ol></li></ul></li><li>响应状态码<ul><li>100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li><li>200  OK   正常返回信息</li><li>201  Created  请求成功并且服务器创建了新的资源</li><li>202  Accepted  服务器已接受请求，但尚未处理</li><li>206  Partial Content  响应报文包含了多个范围内的内容</li><li>301  Moved Permanently  请求的网页已永久移动到新位置。</li><li>302 Found  临时性重定向。</li><li>303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。</li><li>304  Not Modified  自从上次请求后，请求的网页未修改过。</li><li>400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li>401 Unauthorized  请求未授权。</li><li>403 Forbidden  禁止访问。</li><li>404 Not Found  找不到如何与 URI 相匹配的资源。</li><li>500 Internal Server Error  最常见的服务器端错误。</li><li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li></ul></li></ul><h2>各版本简介</h2><h3>HTTP/1.0</h3><ul><li>早先的HTTP/1.0是一种无状态、无连接的应用层协议。规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）</li><li>这种无状态性可以借助cookie/session机制来做身份认证和状态记录。而下面两个问题就比较麻烦了。<ol><li>首先，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。</li><li>其次就是就是队头阻塞（head of line blocking）。由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。</li></ol></li></ul><h3>HTTP/1.1</h3><ul><li>长连接，通过设置<em>Keep-Alive</em>可以保持HTTP连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，提高了网络的利用率。可以在请求头中携带Connection: false来告知服务器关闭请求。</li><li>支持请求管道化（pipelining）。 基于长连接，使得请求管线化成为可能。管线化使得请求能够并行传输。举个例子来说，假如响应的主体是一个html页面，页面中包含了很多img，这个时候keep-alive就起了很大的作用，能够进行并行发送多个请求。（客户端依据域名来向服务器建立连接，一般PC浏览器会针对单个域名的服务器同时建立6 ~ 8个连接，手机端一般控制在4 ~ 6个。这也是为什么很多大型网站设置不同的静态资源CDN域名来加载资源。）<br>需要注意的是，服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。<br>也就是说，HTTP管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）。</li></ul>"
    }
  ]
}